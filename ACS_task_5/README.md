# Архитектура вычислительных систем. Домашнее задание 5.
## Вариант 29. Задача о Пути Кулака.
### Выполнил: Ульяненков Ярослав. БПИ204.
_На седых склонах Гималаев стоит древний
буддистский монастырь: Гуань-Инь-Янь. Каждый год в день сошествия на
землю боддисатвы Монахи монастыря собираются на совместное
празднество и показывают свое совершенствование на Пути Кулака. Всех
соревнующихся монахов разбивают на пары, победители пар бьются затем
между собой и так далее, до финального поединка. Монах который победил в
финальном бою, забирает себе на хранение статую боддисатвы. Реализовать
многопоточное приложение, определяющего победителя. В качестве
входных данных используется массив, в котором хранится количество
энергии Ци каждого монаха. При победе монах забирает энергию Ци своего
противника. Разбивка на пары перед каждым сражением осуществляется
случайным образом. Монах, оставшийся без пары, удваивает свою энергию,
отдохнув от поединка. При решении использовать принцип дихотомии._

## Описание ввода.

При запуске программы при желании запустить автоматическую генерацию монахов 
можно передать в качестве аргумента единственное число - количество автоматически сгенерированных монахов.

        ./executable 111

Это создаст 111 монахов.

В случае неправильных аргументов или при отсутствии аргументов программа предложит 
ввести вручную данные монахов. Сначала программа предложит ввести количество монахов - целое число.
Затем через пробел нужно будет вводить имя монаха и его Ци. Ци должно быть целым числом.

Пример ввода:

    3
    Buddha 5
    Krishna 10
    Brihaspati 4

В своей реализации я использую `std::async`, так как эта обёртка над `std::thread` позволяет получать возвращаемое
из переданной функции значение. Чтобы гарантировать, что она использует потоки, я передаю флаг `std::launch::async`.

Для соблюдения принципа дихотомии я исходный массив монахов рекурсивно делю пополам, после чего каждая из половин 
в отдельном потоке снова делится пополам до тех пор, пока не останется один или два монаха. Если их двое, они устраивают 
поединок, если остаётся один, он отдыхает. дальше по рекурсивному дереву вверх передаются победители, после чего в каждом 
потоке вычисляется свой победитель. И так пока не дойдёт до корня этого рекурсивного дерева, где вычисляется главный победитель.

Чтобы гарантировать случайность, перед каждым разделением массива на два он перемешивается.
